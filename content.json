{"pages":[],"posts":[{"title":"C++-STL","text":"第一章 程序与设计1.1 C -&gt; C++ 头文件层面C -&gt; C++ 头文件层面 : .h后缀消除 1234stdio.h -&gt; cstdiomath.h -&gt; cmathstring.h -&gt; cstring但是要注意: C++的头文件不仅仅是改变了形式，其内部实现也有所不同 C++的输入是从流中提取数据，在输出时需要向流中插入数据 对象名 所属类 含义 cin istream 标准输入,有缓冲 cout ostream 标准输出,有缓冲 cerr ostream 标准错误输出,无缓冲 clog ostream 标准错误输出,有缓冲 缓冲区的概念 : 例如cin 输入数据之后按下enter键才把数据送入键盘缓冲区(若仅仅输入数据仅仅代表放入自带缓存区,但实质上没进行输入操作) 1.2 精度及宽度设置1# include &lt;iomanip&gt; 123456//如果需要小数点后保留精度 需要再加上 cout &lt;&lt; fixed; + sepr~(n);cout &lt;&lt; setprecision(int n) &lt;&lt; d &lt;&lt; endl;//设置以n表示的精度cout &lt;&lt; cout.precision(); //输出当前精度;cout &lt;&lt; cout.witdh(); //输出当前域宽setw(int n) //设置以n表示的域宽 仅仅对后面紧挨着的变量起作用setfill(char c) //设置以c表示的填充字符 第一更 第二章 STL1Blog推荐 : https://cui-jiacai.gitbook.io/c++-stl-tutorial/#qian-dao-zhi-shi 序列容器容器共有的特征 .begin() //调用序列的起始地址 .end() //调用序列的最后一个元素下一个元素的地址 .size() //返回元素个数 //是无符号整型 a.swap(b) //a b两个序列做一个交换 ::iterator //迭代器 关于迭代器 : 迭代器是一个广义的指针，可以是指针也可以是对其进行类似指针操作的对象 123456list&lt;int&gt;::iterator it;list&lt;int&gt; a;for(it=a.begin();it&lt;a.end();++it) cout &lt;&lt; *it &lt;&lt; endl; //迭代器不断迭代void out(int n) cout &lt;&lt; n &lt;&lt; endl;for_each(a,begin(),a.end(),out); 2.1 list - 双向链表在访问时候可以实现向前访问和向后访问，可以在固定时间插入删除，但是不支持==数组的表示法和随机访问== 2.1.1 专用成员函数 merge(x) : 将链表x与调用链表合并，合并之前两个链表必须已经完成排序，合并之后会把合并之后的链表存储到调用链表中，==而链表x将会被清空==； remove(val)：从链表中删除val的所有实例； sort():对链表进行排序； splice(pos,x):将链表x的内容插入到pos的前面，==x将为空==； unique()：将==连续的相同元素==压缩为单个元素。 =&gt; 实现真正去重可以先排序再去重 函数 功能 front() 返回第一个元素 back() 返回最后一个元素 push_front(t) 在list的头部添加一个元素 push_back(t) 在list的末尾添加一个元素 pop_front() 删除第一个元素 pop_back() 删除最后一个元素 insert(pos,t) 插入一个元素到list中(元素t到位置pos) clear() 删除所有元素 erase(p) 删除一个元素 insert(pos,val); 返回值是一个迭代器，指向被插入的元素。 erase(p)函数删除以pos指示位置的元素, 或者删除start和end之间的元素。 返回值是一个迭代器，指向最后一个被删除元素的下一个元素。 2.1.2 案例1234567891011121314151617181920212223# include &lt;list&gt;# include &lt;iterator&gt;//迭代器 # include &lt;iostream&gt; # include &lt;algorithm&gt;//for_each();的头文件 using namespace std;void show(int n){ cout &lt;&lt; n &lt;&lt; &quot; &quot;;}void print(list&lt;int&gt; T){ for_each(T.begin(),T.end(),show); //(首地址,最后一个元素后一个元素的地址,运行函数) cout &lt;&lt; endl;}int main(void){ list&lt;int&gt; one(5,2);//赋值5个2 print(one); return 0;} 首位插入12345678int main(void){ list&lt;int&gt; one(5,2);//赋值5个2 one.push_back(19); //在尾部插入19 one.push_front(20);//在头部插入20 print(one); return 0;} 答案 : 20 2 2 2 2 2 19 insert插入123456789int main(void){ list&lt;int&gt; one(5,2);//赋值5个2 int a[5]={1,2,3,4,5}; one.insert(one.begin(),a,a+3); //插入insert(插入位置,插入数组首位,插入数组末尾加1); print(one); return 0;} 答案 : 1 2 3 2 2 2 2 2 //这是一个空行 删除固定值1234567891011int main(void){ list&lt;int&gt; one(5,2);//赋值5个2 int a[5]={1,2,3,4,5}; one.insert(one.begin(),a,a+3); //插入insert(插入位置,插入数组首位,插入数组末尾加1); print(one); one.remove(2); //remove(const value); print(one); return 0;} 答案 : 1 2 3 2 2 2 2 21 3 //这是一个空行 插入链表123456789int main(void){ list&lt;int&gt; one(5,2);//赋值5个2 list&lt;int&gt; two(3,1); one.splice(one.begin(),two);//链表的插入 要注意one这个链表会被插入 然后插入的链表会被清空 print(one); print(two); return 0;} 答案 : 1 1 1 2 2 2 2 2 //这是一个空行 //这是一个空行 排序123456789101112int main(void){ list&lt;int&gt; one(5,2);//赋值5个2 list&lt;int&gt; two(3,1); int a[5]={1,2,3,4,5}; one.splice(one.begin(),two); one.insert(one.begin(),a,a+3); print(one); one.sort(); print(one); return 0;} 答案 : 1 2 3 1 1 1 2 2 2 2 21 1 1 1 2 2 2 2 2 2 3 //这是一个空行 链表的合并 //必须先排序1234567891011121314int main(void){ list&lt;int&gt; one(5,2);//赋值5个2 list&lt;int&gt; two(3,1); int a[5]={1,2,3,4,5}; one.splice(one.begin(),two); one.insert(one.begin(),a,a+3); print(one); one.sort(); two.sort(); one.merge(two); //合并 并清空two print(one); return 0;} 答案 : 1 2 3 1 1 1 2 2 2 2 21 1 1 1 2 2 2 2 2 2 3 //这是一个空行 链表的去重 - 必须先排序12345678910111213141516int main(void){ list&lt;int&gt; one(5,2);//赋值5个2 list&lt;int&gt; two(3,1); int a[5]={1,2,3,4,5}; one.splice(one.begin(),two); one.insert(one.begin(),a,a+3); print(one); one.sort(); two.sort(); one.merge(two); print(one); one.unique(); //去重 print(one); return 0;} 答案 : 1 2 3 1 1 1 2 2 2 2 21 1 1 1 2 2 2 2 2 2 31 2 3 //这是一个空行 2.2 stack - 栈(后进先出)stack是一个栈，只能在栈顶操作，不支持数组表示法和随机访问。 2.2.1 专业成员函数 push(x): 将x入栈; pop(): 删除栈顶; top(): 返回指向栈顶元素的引用; size(): 返回栈中元素个数; empty(): 判栈空,若为空返回true; 2.2.2 案例12345678910# include &lt;stack&gt;# include &lt;iostream&gt;using namespace std;int main(void){ stack&lt;int&gt; s; return 0;} 压栈出栈(后进先出)12345678910111213# include &lt;stack&gt;# include &lt;iostream&gt;using namespace std;int main(void){ stack&lt;int&gt; s; for(int i=0;i&lt;=5;++i) s.push(i); //入栈 cout &lt;&lt; s.top();//打印栈顶元素 return 0;} 答案 : 5 123456789101112int main(void){ stack&lt;int&gt; s; for(int i=0;i&lt;=5;++i) s.push(i); //出栈 while(!s.empty()){ cout &lt;&lt; s.top() &lt;&lt; &quot; &quot;; s.pop();//出栈 } return 0;} 答案 : 5 4 3 2 1 0 2.3 queue - 队列(先进先出)queue是一个队列，只能在队尾入队，队头出队，不支持数组表示法和随机访问。 2.3.1 专业成员函数 push(x) : 将x插入队尾; pop() : 删除队头; front() : 返回指向队头元素的引用; back() : 返回指向队尾元素的引用; size() : 返回队中元素个数; empty() : 判队空，若为空返回true; 2.3.2 案例入队列出队列12345678910111213141516# include &lt;queue&gt;# include &lt;iostream&gt;using namespace std;int main(void){ queue&lt;int&gt; q; for(int i=0;i&lt;=5;++i) q.push(i); while(!q.empty()){ cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; q.pop(); //出队列;队列先进先出 } return 0;} 答案 : 0 1 2 3 4 5 2.4 priority_queue - 优先队列(根据优先级顺序出去) 底层实现是堆priority_queue是一个优先队列，按照优先级出队，默认越大越优先，不支持数组表示法和随机访问。 2.4.1 专业成员函数 push(x) : 将x插入队中; pop() : 删除队头; top() : 返回指向队头元素的引用; size() : 返回队中元素个数; empty() : 判队空，若为空返回true; 2.4.2 案例入队列出队列1234567891011121314151617# include &lt;queue&gt;# include &lt;iostream&gt; using namespace std;int main(void){ priority_queue&lt;int&gt; q; for(int i=0;i&lt;=5;++i) q.push(i); q.push(100); while(!q.empty()){ cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;; q.pop();//出队列 } return 0;} 答案 : 100 5 4 3 2 1 0 当如果是结构体就需要重载小于号 12345678910111213141516171819202122232425262728# include &lt;queue&gt;# include &lt;iostream&gt; using namespace std;struct good{ double w; double v;}g[100];bool operator &lt;(const good &amp;a,const good &amp;b){ return a.v&lt;b.v;//越大越优先 //return a.v&gt;b.v;//越小越优先 }int main(void){ priority_queue&lt;good&gt; q; for(int i=0;i&lt;=5;++i){ cin &gt;&gt; g[i].v &gt;&gt; g[i].w; q.push(g[i]); } while(!q.empty()){ cout &lt;&lt; q.top().w &lt;&lt; &quot; &quot; &lt;&lt; q.top().v &lt;&lt; endl; q.pop();//出队列 } return 0;} 输入: 12 213 232 38 21 325 2 输出 : 2 2523 132 122 83 23 1 2.5 deque - 双端队列(两端都可以进出)deque，是一个双端队列，可以在两端进出队，支持数组表示法和随机访问。经常在序列两端操作时使用该函数。类似vector。 2.5.1 专业成员函数 push_front(x)/push_back(x) : 从队头/队尾入队; pop_front()/pop_back() : 从队头/队尾出队; front()/back() : 返回指向队头/队尾元素的引用; size() : 返回队中元素个数; empty() : 判队空，若为空返回true; clear() : 清空队列; 2.5.2 案例入队列出队列队列长度1234567891011121314151617181920212223242526272829303132# include&lt;deque&gt;# include&lt;iostream&gt;# include&lt;algorithm&gt;using namespace std;void show(int n){cout &lt;&lt; n &lt;&lt; &quot; &quot;;}void print(deque&lt;int&gt; &amp;T){ for_each(T.begin(),T.end(),show); cout &lt;&lt; endl;}int main(void){ deque&lt;int&gt; dq; for(int i=1;i&lt;=5;++i) dq.push_back(i); for(int i=1;i&lt;=5;++i) dq.push_front(i); print(dq); for(int i=1;i&lt;=2;++i) dq.pop_back(); print(dq); for(int i=1;i&lt;=2;++i) dq.pop_front(); print(dq); cout&lt;&lt;dq.size()&lt;&lt;endl; dq.clear(); cout&lt;&lt;dq.size(); return 0;} 答案 : 5 4 3 2 1 1 2 3 4 55 4 3 2 1 1 2 33 2 1 1 2 360 第二更 2.6 vector - 可变长数组vector是序列容器 vector是变长数组，支持数组表示法和随机访问 2.6.1 专业成员函数 函数 功能 size() 返回Vector元素数量的大小 empty() 判Vector是否为空（空返回true） clear() 清空所有元素 begin() 返回第一个元素的迭代器 end() 返回最末元素的迭代器(译注:实指向最末元素的下一个位置) front() 返回第一个元素 back() 返回最末一个元素 push_back() 在Vector最后添加一个元素 pop_back() 移除最后一个元素 erase() 删除指定元素 insert() 插入元素到Vector中 2.6.2 案例12345678910# include&lt;vector&gt;# include&lt;iostream&gt;using namespace std;int main(void){ vector&lt;int&gt; v; return 0;} 插入输出12345678910111213int main(void){ vector&lt;int&gt; v; for(int i=0;i&lt;10;++i) v.push_back(i); for(int i=0;i&lt;10;++i) cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; v.insert(v.begin()+2,100); for(int i=0;i&lt;10;++i) cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; return 0;} 答案 : 0 1 2 3 4 5 6 7 8 90 1 100 2 3 4 5 6 7 8 恢复原本状态12vector&lt;int&gt; oldv(v);//把v的内容全部复制给oldvv.swap(oldv); 删除元素123v.erase(v.begin()+2,v.end()-2); //删除范围元素for(int i=0;i&lt;v.size();++i) cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; 答案 : 0 1 8 9 这里面有一个需要注意的地方 123v.erase(v.begin()+2,v.end()-2); //删除范围元素for(int i=0;i&lt;10;++i) cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; 答案 : 0 1 8 9 3 4 5 6 7 8 这个删除不是真的删除 在下次插入之前内容仍然存在 并没有真正的删除 迭代器输出123vector&lt;int&gt;::iterator it;for(it=v.begin();it&lt;v.end();++it) cout &lt;&lt; *it &lt;&lt; &quot; &quot;; 答案 : 0 1 2 3 4 5 6 7 8 9 关联容器set/multiset/map/multimap的底层实现都是红黑树 插入删除查找的速度快O(logn)2.7 set/multiset/bitset - 关联容器 集合(不允许重复)/多值集合(允许重复)/位运算set是==有序集合==，multiset是==有序多重集合==。可翻转、经过排序的关联容器。键和值类型一致。内部实现为红黑树。 关联容器将值和键关联在一起，通过键来查找值。set/multiset是键=值的关联容器 不是二元组 2.7.1 专业成员函数 size()/empty()/clear()/erase(); begin()/end(); find()/insert(); count(); //统计等于x的个数 lower_bound()/unper_bound() //大于等于x的最小的/大于x的最小的 2.7.2 案例插入输出1234567891011121314151617181920# include&lt;set&gt;# include&lt;iostream&gt;using namespace std;void print(set&lt;int&gt; &amp;T){ set&lt;int&gt;::iterator it; for(it=T.begin();it!=T.end();++it) cout &lt;&lt; *it &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; }int main(void){ set&lt;int&gt; s; for(int i=0;i&lt;10;++i) s.insert(i); print(s); return 0;} 答案 : 0 1 2 3 4 5 6 7 8 9 做插入操作的时候会帮你排序 12s.insert(80);s.insert(5); //如果已经有了的就什么也不做 也不会提示 答案 : 0 1 2 3 4 5 6 7 8 9 80 12345678910111213141516171819202122# include&lt;set&gt;# include&lt;iostream&gt;using namespace std;void print(multiset&lt;int&gt; &amp;T){ multiset&lt;int&gt;::iterator it; for(it=T.begin();it!=T.end();++it) cout &lt;&lt; *it &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; }int main(void){ multiset&lt;int&gt; s; for(int i=0;i&lt;10;++i) s.insert(i); s.insert(80); s.insert(5); print(s); return 0;} 答案 : 0 1 2 3 4 5 5 6 7 8 9 80 删除1s.erase(5); //删除所有5 答案 : 0 1 2 3 4 6 7 8 9 80 2.8 map/multimap - 关联容器键值对 键和值可以不同类型。map是一个键值对映射(一一对应)，multimap一个键可以与多个值关联。可翻转、经过排序的关联容器。键和值类型可以不同。内部实现为红黑树。 2.8.1 专业成员函数 size()/empty()/clear()/erase(); begin()/end(); find()/insert(): 2.8.2 案例map插入1234567891011121314151617181920212223242526# include&lt;map&gt;# include&lt;string&gt;# include&lt;iostream&gt;using namespace std;map&lt;string,int&gt; cnt;string s;void print(map&lt;string,int&gt; &amp;T){ map&lt;string,int&gt;::iterator it; for(it=T.begin();it!=T.end();++it) cout &lt;&lt; (*it).first &lt;&lt; &quot;\\t&quot; &lt;&lt; (*it).second &lt;&lt; endl;}int main(void){ int n; cin &gt;&gt; n; for(int i=0;i&lt;n;++i){ cin &gt;&gt; s; cnt[s]++; } print(cnt); return 0;} 答案 : 5ac ac da ds daac 2da 2ds 1 multimap 插入1234567891011121314151617181920212223242526# include&lt;map&gt;# include&lt;string&gt;# include&lt;iostream&gt;using namespace std;multimap&lt;string,int&gt; cnt;string s;void print(multimap&lt;string,int&gt; &amp;T){ multimap&lt;string,int&gt;::iterator it; for(it=T.begin();it!=T.end();++it) cout &lt;&lt; (*it).first &lt;&lt; &quot;\\t&quot; &lt;&lt; (*it).second &lt;&lt; endl;}int main(void){ int n; cin &gt;&gt; n; for(int i=0;i&lt;n;++i){ cin &gt;&gt; s; cnt.insert(make_pair(s,i)); } print(cnt); return 0;} 插入1234567891011int main(void){ int n; cin &gt;&gt; n; for(int i=0;i&lt;n;++i){ cin &gt;&gt; s; cnt.insert(make_pair(s,i)); //make_pair()二元组传入 } print(cnt); return 0;} 答案 : 4ac ac sa sdac 0ac 1sa 2sd 3 常用函数2.9 sort //排序函数时间复杂度: O(nlogn) 通常认为sort()的内部实现是快速排序 优先级定义： 自定义优先级 运算符重载 12# include &lt;algorithm&gt; 头文件#include&lt;functional&gt; greater升序 less降序 排序有两种方式: 使用less 和 greater 使用自定义函数 使用less 和 greater排序12345678910111213141516#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;using namespace std;int a[100]; int main() { for(int i=0;i&lt;10;i++) a[i]=i; sort(a,a+10,greater&lt;int&gt;());//greater降序less升序 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot;\\t&quot;; return 0;} 使用自定义函数123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;using namespace std;int a[100]; bool cmp(int a,int b)//自定义优先级 { return a&gt;b;}int main() { for(int i=0;i&lt;10;i++) a[i]=i; sort(a,a+10,cmp); for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot;\\t&quot;; return 0;} 2.10 reverse/random_shuffle/uniquereverse 翻转 random_shuffle 随机打乱 unique 去重 1# include &lt;algorithm&gt; 头文件 案例 : 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt; using namespace std;void print(vector&lt;int&gt; &amp;T){ for(vector&lt;int&gt;::iterator it=T.begin();it!=T.end();it++) cout&lt;&lt;*it&lt;&lt;&quot;\\t&quot;; cout&lt;&lt;endl;}int main() { vector&lt;int&gt;a; int b[3]={0}; for(int i=0;i&lt;=10;i++) a.push_back(i); cout&lt;&lt;a.size()&lt;&lt;endl; print(a); cout&lt;&lt;endl; reverse(a.begin(),a.end()); print(a); cout&lt;&lt;endl; random_shuffle(a.begin(),a.end()); print(a); cout&lt;&lt;endl; a.insert(a.begin()+2,5); a.insert(a.begin()+2,5); print(a); cout&lt;&lt;endl; unique(a.begin(),a.end()); print(a); cout&lt;&lt;endl; return 0;} 答案 : 110 1 2 3 4 5 6 7 8 9 10 10 9 8 7 6 5 4 3 2 1 0 0 9 1 8 10 5 3 7 6 4 2 0 9 5 5 1 8 10 5 3 7 6 4 2 0 9 5 1 8 10 5 3 7 6 4 2 2","link":"/2022/04/11/C-STL/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/04/03/hello-world/"},{"title":"tmux","text":"1. tmux教程功能：​ (1) 分屏。​ (2) 允许断开Terminal连接后，继续运行进程。 结构：一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。 实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1 window 2 ... session 1 session 2 ... 操作：​ (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。​ (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。​ (3) 按下Ctrl + a后手指松开，然后按”：将当前pane上下平分成两个pane。​ (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。​ (5) 鼠标点击可以选pane。​ (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。​ (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。​ (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。​ (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。​ (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。​ (11) tmux a：打开之前挂起的session。​ (12) 按下ctrl + a后手指松开，然后按s：选择其它session。​ 方向键 —— 上：选择上一项 session/window/pane​ 方向键 —— 下：选择下一项 session/window/pane​ 方向键 —— 右：展开当前项 session/window​ 方向键 —— 左：闭合当前项 session/window​ (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。​ (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。​ (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。​ (16) 鼠标滚轮：翻阅当前pane内的内容。​ (17) 在tmux中选中文本时，需要按住shift键。 2. vim教程功能：(1) 命令行模式下的文本编辑器。 (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。 (3) 使用方式：vim filename 如果已有该文件，则打开它。 如果没有该文件，则打开个一个新的文件，并命名为filename 模式：(1) 一般命令模式 默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。 (2) 编辑模式 在一般命令模式里按下i，会进入编辑模式。 按下ESC会退出编辑模式，返回到一般命令模式。 (3) 命令行模式 在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。 可以查找、替换、保存、退出、配置编辑器等。 操作：(1) i：进入编辑模式 (2) ESC：进入一般命令模式 (3) h 或 左箭头键：光标向左移动一个字符 (4) j 或 向下箭头：光标向下移动一个字符 (5) k 或 向上箭头：光标向下移动一个字符 (6) l 或 向右箭头：光标向右移动一个字符 (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符 (8) 0 或 功能键[Home]：光标移动到本行开头 (9) $ 或 功能键[End]：光标移动到本行末尾 (10) G：光标移动到最后一行 (11) :n 或 nG：n为数字，光标移动到第n行 (12) gg：光标移动到第一行，相当于1G (13) n&lt;Enter&gt;：n为数字，光标向下移动n行 (14) /word：向光标之下寻找第一个值为word的字符串。 (15) ?word：向光标之上寻找第一个值为word的字符串。 (16) n：重复前一个查找操作 (17) N：反向重复前一个查找操作 (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2 (19) :1,$s/word1/word2/g：将全文的word1替换为word2 (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。 (21) v：选中文本 (22) d：删除选中的文本 (23) dd: 删除当前行 (24) y：复制选中的文本 (25) yy: 复制当前行 (26) p: 将复制的数据在光标的下一行(==按行复制时候==)/下一个位置(==按选中复制时候==)粘贴 (27) u：撤销 （ctrl+z挂起-fg是调出进程） (28) Ctrl + r：取消撤销 (29) 大于号 &gt;：将选中的文本整体向右缩进一次 (30) 小于号 &lt;：将选中的文本整体向左缩进一次 (31) :w 保存 (32) :w! 强制保存 (33) :q 退出 (34) :q! 强制退出 (35) :wq 保存并退出 (36) :set paste 设置成粘贴模式，取消代码自动缩进 (37) :set nopaste 取消粘贴模式，开启代码自动缩进 (38) :set nu 显示行号 (39) :set nonu 隐藏行号 (40) gg=G：将全文代码格式化 (41) :noh 关闭查找关键词高亮 (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令 异常处理： 每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。 如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种： (1) 找到正在打开该文件的程序，并退出 (2) 直接删掉该swp文件即可 ctrl+z撤销 ctrl+shift+z（ctrl+y）取消撤销 ggdG：gg到开头d删除G到最后 gg=G全文格式化","link":"/2022/04/04/tmux/"},{"title":"常用文件管理命令","text":"一、常用文件管理命令1. 常用命令介绍 快捷键 1234567891011(1) ctrl + c: 取消命令，并且换行(2) ctrl + u: 清空本行命令(3) ctrl + l: 清空屏幕 == clear命令(4) shift + del: 永久删除(5) tab键：[代码补全] 可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项(6) 复制文本 windows/Linux下：Ctrl + insert，Mac下：command + c(7) 粘贴文本 windows/Linux下：Shift + insert，Mac下：command + v(8) 打开终端 ctrl + t 目录相关 123456(1) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件(2) pwd: 显示当前路径(3) mkdir XXX: [创建目录XXX] mkdir a/b/c -p(创建文件夹类型文件)(4) touch XXX: [创建文件] 创建一个文件(5) cat XXX: 展示文件XXX中的内容 cat &gt; file: 创建文件并从键盘获取内容 cat file1 file2 &gt; file3: 合并文件 复制、粘贴、删除 12345(6) cd XXX: [进入目录] 进入XXX目录下, cd .. 返回上层目录 cd - 返回上一次的目录（一直反复会在两个路径之间不断切换）(7) cp XXX YYY: [复制/粘贴/重命名] 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt cp a b -r: [复制目录](9) rm XXX: 删除普通文件; rm XXX -r: 删除文件夹(-r是迭代式删除)(10) mv XXX YYY: [剪切+粘贴] 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令 2. 创建作业 &amp; 测试作业的正确性1234homework 1 create 可以重新创建所有lesson_1的作业homework 1 create id 可以单独创建lesson_1的第id个作业. homework 1 create 0 可以只重新创建lesson_1的第0个作业homework 1 test 可以评测lesson_1的所有作业 3. 作业123456789101112131415lesson_1 -- 基于Acwing提供的AC Terminal创建好作业后，先进入文件夹/home/acs/homework/lesson_1/，然后：(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2， 将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt; 将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt; 将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作(9) 进入homework_9文件夹，将其中所有txt类型的文件删除 -h 人性化处理","link":"/2022/04/04/%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-1/"},{"title":"考研日记","text":"​ 今天这个情人节很特殊，遇到了很多不开心的事情，原本期待已久的返校也因为苏州的疫情而延期(或者说遥遥无期)。也因为疫情不能正常返校，让我思考了很多事情。例如，在这样一个大环境下，我在大学期间学到了什么？我又有什么核心竞争力？毕竟我现在也已经即将21岁正式进入奔三的行列，我现在也已经算进入大三下学期这一阶段，其实想想如果我选择考研这条路的话，以后的经历和重心都会偏向考研这个方向。 ​ 但是，像疫情这件事给我敲了一个警钟，疫情不会等我，考研结束如果我一点技术不懂我甚至无法去完成我的毕设以及即将面临的毕业实习，这样一个又一个的事情都会在考研初试(12.26)结束之后接踵而来。这样一个又一个现实的问题我不得不去考虑。而考研这样一件事情如果我不沉下心并且花费大量的精力我也不觉得我自己可以成功。 ​ 另外，在今天我似乎想通了一件事情，我其实在之前有些资料不愿意和别人共享并且在得知别人也有这样一个资料之后会害怕自己会学不过人家。其实今天思考过之后想明白了这个道理，真正想学的人自然有更多更好的资料，如果我固步自封不和别人交流，那最后最受影响的其实将是我自己。真正想学习的人没有找不到的资源，那么同样的不想学的人有再多的资源也仅仅是资源浪费罢了。我之前的想法就是这样的，我是自己学的东西不多，期望自己用少数的时间就可以获得更多更好收获，但其实正如现实所告诉我的那样，完全不会，没付出就会没收获。我也不是什么天才人物，又怎么可能做到不劳而获呢。 ​ 最后给自己一个寄语吧。考研也只是我人生众多选择的一条，不一定走不通这个就一定一事无成，更希望可以在为这件事情付出自己十二分的努力之后，在努力过程中所得到的收获将是我一辈子的财富。共勉！","link":"/2022/04/04/%E8%80%83%E7%A0%94%E6%97%A5%E8%AE%B0-1/"}],"tags":[{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"hello-world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"tmux","slug":"tmux","link":"/tags/tmux/"},{"name":"linux命令","slug":"linux命令","link":"/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"感悟","slug":"感悟","link":"/tags/%E6%84%9F%E6%82%9F/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"icarus","slug":"icarus","link":"/categories/icarus/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"考研","slug":"考研","link":"/categories/%E8%80%83%E7%A0%94/"}]}